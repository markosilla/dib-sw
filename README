===============================================================================
                            RCS HW Test information
                                 and guidelines
===============================================================================

This README contain the following:

* Build procedure
* How the testmgr/testagt framework works (TODO)
* How to run Cold With Test (CWT)
* HW log message guidelines (TODO)
* Printout format for Production Test / Cold W Test commands
* Return codes/printout
* hwtest-errno.h


===============================================================================
Build procedure
===============================================================================
The following steps are based on generic information in the rcs-yocto
repository, please check out the doc/README_sdk.txt in the rcs-yocto repository
for more information.

  1. Change directory to your subrepo, e.g.
     cd rcs-hwtest

  2. Source the rcs-sdk-setup script (run once)
     The script needs the track as first argument e.g. master, 16b, etc
     Usually you want to build against latest/master i.e:
     . <rcs-yocto repo>/make/rcs-sdk-setup.bash master

  3. Run autoreconf (run once)
     autoreconf will call the needed aclocal, subtools etc:
     mkdir -p m4 && autoreconf -f -i -v

  4. Run configure (run once), NOTE there could be different configure flags
     for different purposes.
     ./configure $CONFIGURE_FLAGS

  4.1 Building for CPM2 board.
      export CFLAGS=${CFLAGS}" -DNCP_32_BIT_COMPAT"

  5. Build
     make -j

  6. Optionally do a install:
     make DESTDIR=$(pwd)/my_install install

  7. Copy binaries to target, e.g:
     scp my_install/.../bin/foobar root@1.2.3.4:/tmp


===============================================================================
How the testmgr/testagt framework works
===============================================================================
TBD


===============================================================================
How to run Cold W Test (CWT)
===============================================================================
There are different ways of running CWT depending on where you are in the
system and if you want to make a short cut for some reason

* From linux terminal with u-boot tests.
pgh_restartbrd -h

* From u-boot with u-boot tests.
restart coldwtest

* From u-boot without u-boot tests on CPM1.
mw 0x900300ec 0x10; mw 0x900300f0 0x1; mw 0x20000000 0xAFFE0001;
mw 0x20000004 0; mw 0x20000008 0xEBBAAAAA; rcs

* From u-boot without u-boot tests on CPM2.
mw 0x8002c000ec 0x1800; mw 0x8002c000f0 0x1; mw 0x20000000 0xAFFE0001;
mw 0x20000004 0; mw 0x20000008 0xEBBAAAAA; rcs


===============================================================================
HW log message guidelines
===============================================================================
TBD


===============================================================================
Production test/CWT printout format
===============================================================================
All of the CWT test commands shall be run in factory when running the board
production test. The purposes with this is to make sure that the CWT is working
on all produced board before they leave the factory. Also, we gain development
time since we do not need to develope two different tests that bascially do the
same thing, or test the same HW component.

The PTD needs to map the tests to their 15241 document and therefor, and also
for tracking purpose, they want the CWT/PTD test commands to print out the
different steps in the test. The printout should have this format:

  <HWLogID>; S1: <key-1>; <value>
  <HWLogID>; S2: <key-2>; <value>
  ...
  <HWLogID>; Sn: <key-N>; <value>

Where
  HWLogID is a three letter/number string.
  S1..Sn  is the step number, S1 for step one, S2 for step 2 etc. These steps
          should also be agreed with PTD.
  key     is a string describing what is happening in this step.
  value   value is the outcome string, usually OK or NOK (but in special cases
          it could be something different.

E.g. when running retimer test it looks like this:
  AID; S1: retimer ri0(tx), read register 0x0 and store original value; OK
  AID; S2: retimer ri0(tx), write new value 0x12 to register 0x0; OK
  AID; S3: retimer ri0(tx), read back and compare; OK
  AID; S4: retimer ri0(tx), restore original value 0x0 to register 0x0; OK


===============================================================================
Return codes/printout
===============================================================================
Return codes from low level or test commands should look like:

  testbox <command>
  ...
  <command> :: TESTBOX_PASS

Or if there is a failure of some sort, always return an error printout and then
return fail:

  testbox <command>
  ...
  ERROR: <error message>
  <command> :: TESTBOX_FAIL

Also, a general guideline to the printouts is to use the <key>: <value> output.
E.g. when reading a retimer register the output should look like this:

  testbox retimer_read ri0 rx 0x10
  0x10: 0x18
  retimer_read :: TESTBOX_PASS

  In the example above <key> is the address and <value> is the register value.

===============================================================================
An example for a CwT/testbox testcase. The intention of this exmaple is just
to show how to use the macros.
===============================================================================

static int exampletest(const char *port)
{
	int ret = 0;
	uint32_t status = 0;
	uint32_t address = 0x1234;
	uint32_t data = 0xabbababe;
	uint32_t port_num;

	/* A macro that initializes variables that is used during logging */
	TC_INIT();

	/* Initial parameter checks */
	if (rhai_portid_s_to_p(port, &port_num)) {
		htsd_printf(LOG_ERR, "ERROR: <%s>, unknown port\n", port);
		ret = SW_FAULT; /* SW fault, testmgr will hide this */
		goto tc_end;
	}

	/* This is an example for a write operation to some device */
	TC_STEP(HWLOGID_PHY_ACCESS, __write(port_num, address, data),
		"Write 0x%04x to address 0x%04x in phy %s", data, address,
		port);

	/* Read data from a device. */
	TC_STEP(HWLOGID_PHY_ACCESS, __read(port_num, address, &data),
		"Read address 0x%04x from phy %s", port);

	TC_END();

	if (ret && ret != SW_FAULT) {
		/* An error description to hwlog. Describe which test this is
		 * so the reader understand where to find more description
		 * of the testcase. */
		LOG_HWERR(hwlogid, "Phy access test on port %s failed.", port);
	}

	/* Cleanup (if necessary) */

	return ret;
}

void test_exampletest_cmd_usage()
{
	htsd_printf(LOG_INFO, "NAME\n"
		"\texampletest - Just an example\n"
		"SYNOPSIS\n"
		"\texampletest <port>\n"
		"DESCRIPTION\n"
		"\tSome description\n"
		"OPTIONS\n"
		"\t<port>  - An example argument\n");
}

/* This test fulfills the requirement CPM_00xx */
static int test_exampletest_cmd(int argc, char **argv, void *unused)
{
	/* Validate that at least one argument is specified, i.e. argv[1] is
	 * defined and print help menu if requested. */
	CMD_CHECK_ARG(test_exampletest_cmd_usage, 1)

	/* Execute one or several tc's */
	return exampletest(argv[1]);
}


===============================================================================
hwtest-errno.h
How to return fault codes from function calls
===============================================================================

History:
-------
Fault codes in hwtest have been -errno of some kind. A best fit of errno have
been chosen, or "-1" if no errno code was taken. This is a legacy from beeing
part of rhai.
When in-field tests was started there was a need to distinguish between soft
and hard faults to avoid red-marking a board if the problem is a soft error.
for that case ONE fault code was taken that covers all possible fault cases.

Problem:
-------
* There is no formal  definition of the fault code type
* The errno codes are not very suited for hardware test kind of faults since
  they are mainly os and interconnect focused.
* Having ONE soft fault code only limits the possibility to take action if
  such a need would occurr since it is impossible to tell what is wrong with
  only one code.
* Not having a clear strategy regarding fault codes makes it alot more
  impractical if partial fault handling should be introduced. You must have
  a solid foundation to be able build something on top of it.
* Since not all functions have been implemented using the same concept many
  functions that are designed earlier do not distinguish between soft and hard
  faults, hence the TC_STEP function cannot be used since special handling must
  be done on the fault code returned from these earlier functions.
* Since the fault codes are minus something we cannot use a bit to distinguish
  between soft and hard faults.
* Since the fault code is defined as int normally we cannot really tell where
  the negative bit is since int can be both 32 bit and 64 bit wide.

Suggested solution:
------------------
* Define a new header file hwtest-errno.h
* include errno.h in the hwtest-errno.h, so that we still allow the old style
  of fault codes to ease/avoid migration.
* Start a new series of fault codes ranging from 256 and upwards. They can then
  be specific to hwtest.
* When possible redefine the errno to have an hwt_errno instead, like EPERM
  can be defined as HWT_EPERM. The advantage is that we can write a detailed
  description ourselfves, even though this one is fairly obvious, but also we
  need not invent new stuff if they are already present.
* Replace all present SW_FAULT returns with the macro described below plus a
  suitable fault code.
* Replace the SW_FAULT definition with a SW_FAULT code by redefining the
  SW_FAULT into beeing a positive number.
* Introduce macros that makes fault code SW_FAULT or HW_FAULT
  HW_FAULT will be negative to be compatible with todays solution.
* introduce macro that returns true/false (1/0) for sw and hw faults.
* There must be no zero numbered fault code, i.e (fault & 0xff) != 00.
* Initiall use int as error code type, since that is what is used today.
* Long term we should declare a type "hwterr_t" to be used for all
  functions returning a fault code. Initially it can be declated as int. The
  advantage would be that we could "easily" change this if anything would
  require so (32/64 bit seems be ok in that sense).

Migration path:
--------------

* The migration from present fault codes into the new ones should be done
  iteratively so things will keep working during the change

>> Step 1
+ First create the hwt-errno.h file
+ Add the SW HW fault utility macros into the errno file.
+ Create a general fault code for non specific faults called HWT_ERR.
  This fault code can be used for not yet specified faults "-1".
+ Move SW_FAULT definition from htsd-cmd.h into hwt-errno.h.
+ redefine SW_FAULT" to be a SW fault by default to avoid needing to change
  at every place we have "return SW_FAULT".
+ Update test manager to handle the new defines.
+ Use an intermediate name for SW_FAULT as SWF to be able to do
  step 2 as one complete push.
+ Do some initial test implementation to verify the basic principles.

>> step 2 (needed to have a short gap to avoid merger issues)
+ Change to have SW_FAULT as a macro, and replace all places where SW_FAULT
  is used to have the macro instead.
+ The default code HWT_ERR initially.

>> Step 3
+ Relace all "return -1" with "return HWT_ERR".
+ Set all fault codes explicitly as either SW or HW, and not implicitly treat
  all "-errno" as HW faults.

>> Step 4 (optional)
+ Relace all "return HWT_ERR" with a specific error code instead.

>> step 5 (extra)
+ replacing the commonly used int in favour of hwterror_t
